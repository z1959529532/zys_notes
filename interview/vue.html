<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>Vue系列 | zys-conclusion</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/zys_notes/assets/imgs/favicon.ico">
    <meta name="description" content="Welcome to zys_notes">
    <meta name="author" content="zys">
    <meta name="keywords" content="使用vuepress">
    
    <link rel="preload" href="/zys_notes/assets/css/0.styles.a1da0401.css" as="style"><link rel="preload" href="/zys_notes/assets/js/app.27d2a2d1.js" as="script"><link rel="preload" href="/zys_notes/assets/js/2.dfcfa016.js" as="script"><link rel="preload" href="/zys_notes/assets/js/24.9b45613e.js" as="script"><link rel="prefetch" href="/zys_notes/assets/js/10.cfacbde0.js"><link rel="prefetch" href="/zys_notes/assets/js/11.7152949e.js"><link rel="prefetch" href="/zys_notes/assets/js/12.89311dc4.js"><link rel="prefetch" href="/zys_notes/assets/js/13.f00188eb.js"><link rel="prefetch" href="/zys_notes/assets/js/14.703aa30f.js"><link rel="prefetch" href="/zys_notes/assets/js/15.c9296715.js"><link rel="prefetch" href="/zys_notes/assets/js/16.7537c97d.js"><link rel="prefetch" href="/zys_notes/assets/js/17.beaa65a7.js"><link rel="prefetch" href="/zys_notes/assets/js/18.53136da5.js"><link rel="prefetch" href="/zys_notes/assets/js/19.35e09296.js"><link rel="prefetch" href="/zys_notes/assets/js/20.b72ad227.js"><link rel="prefetch" href="/zys_notes/assets/js/21.d60756f5.js"><link rel="prefetch" href="/zys_notes/assets/js/22.c3b19fb6.js"><link rel="prefetch" href="/zys_notes/assets/js/23.55ad0ebc.js"><link rel="prefetch" href="/zys_notes/assets/js/25.42cf1f68.js"><link rel="prefetch" href="/zys_notes/assets/js/26.3af6579d.js"><link rel="prefetch" href="/zys_notes/assets/js/27.a765196c.js"><link rel="prefetch" href="/zys_notes/assets/js/28.9641a23b.js"><link rel="prefetch" href="/zys_notes/assets/js/29.58de9ec5.js"><link rel="prefetch" href="/zys_notes/assets/js/3.48a24a76.js"><link rel="prefetch" href="/zys_notes/assets/js/30.042fd9db.js"><link rel="prefetch" href="/zys_notes/assets/js/31.09968ecf.js"><link rel="prefetch" href="/zys_notes/assets/js/32.de245d2f.js"><link rel="prefetch" href="/zys_notes/assets/js/33.a4ef8d72.js"><link rel="prefetch" href="/zys_notes/assets/js/4.0e8dcff8.js"><link rel="prefetch" href="/zys_notes/assets/js/5.aa9851b9.js"><link rel="prefetch" href="/zys_notes/assets/js/6.99ad772a.js"><link rel="prefetch" href="/zys_notes/assets/js/7.0adce77b.js"><link rel="prefetch" href="/zys_notes/assets/js/8.e3455c10.js"><link rel="prefetch" href="/zys_notes/assets/js/9.6f3c5772.js">
    <link rel="stylesheet" href="/zys_notes/assets/css/0.styles.a1da0401.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/zys_notes/" class="home-link router-link-active"><img src="/zys_notes/assets/imgs/header.png" alt="zys-conclusion" class="logo"> <span class="site-name can-hide">zys-conclusion</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/zys_notes/vp-notes/" class="nav-link">
  Vuepress
</a></div><div class="nav-item"><a href="/zys_notes/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/zys_notes/interview/vue.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  面试问题
</a></div><div class="nav-item"><a href="/zys_notes/timeline/" class="nav-link">
  时间线
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/zys_notes/vp-notes/" class="nav-link">
  Vuepress
</a></div><div class="nav-item"><a href="/zys_notes/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/zys_notes/interview/vue.html" aria-current="page" class="nav-link router-link-exact-active router-link-active">
  面试问题
</a></div><div class="nav-item"><a href="/zys_notes/timeline/" class="nav-link">
  时间线
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/zys_notes/" aria-current="page" class="sidebar-link">首页</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/zys_notes/vue/start" class="sidebar-heading clickable"><span>vue学习</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/zys_notes/vite/vite.html" class="sidebar-link">vite学习</a></li><li><a href="/zys_notes/uniapp/uniapp.html" class="sidebar-link">uniapp学习</a></li><li><a href="/zys_notes/angular/angular.html" class="sidebar-link">Angular</a></li><li><a href="/zys_notes/websocket/websocket.html" class="sidebar-link">Websocket</a></li><li><section class="sidebar-group depth-0"><a href="/zys_notes/basis/" class="sidebar-heading clickable"><span>前端基础</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/zys_notes/basis/learn-html.html" class="sidebar-link">html部分</a></li><li><a href="/zys_notes/basis/learn-css.html" class="sidebar-link">css部分</a></li></ul></section></li><li><a href="/zys_notes/ajax/" class="sidebar-link">ajax</a></li><li><a href="/zys_notes/promise/" class="sidebar-link">Promise</a></li><li><a href="/zys_notes/axios/" class="sidebar-link">axios</a></li><li><a href="/zys_notes/iframe/" class="sidebar-link">iframe通信</a></li><li><section class="sidebar-group depth-0"><a href="/zys_notes/interview/" class="sidebar-heading clickable router-link-active open"><span>准备</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/zys_notes/interview/encapsulation.html" class="sidebar-link">实现总结</a></li><li><a href="/zys_notes/interview/vue.html" aria-current="page" class="active sidebar-link">Vue系列</a><ul class="sidebar-sub-headers"></ul></li><li><a href="/zys_notes/interview/js.html" class="sidebar-link">JS系列</a></li><li><a href="/zys_notes/interview/css.html" class="sidebar-link">CSS系列</a></li><li><a href="/zys_notes/interview/webpack.html" class="sidebar-link">Webpack</a></li><li><a href="/zys_notes/interview/http.html" class="sidebar-link">http系列</a></li><li><a href="/zys_notes/interview/webgis.html" class="sidebar-link">WebGis系列</a></li><li><a href="/zys_notes/interview/vueDiff.html" class="sidebar-link">Vue虚拟Dom与Diff算法</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h3 id="目录"><a href="#目录" class="header-anchor">#</a> 目录</h3> <ul><li><a href="/zys_notes/interview/vue.html#对vue看法">对Vue看法</a></li> <li><a href="/zys_notes/interview/vue.html#spa">SPA</a></li> <li><a href="/zys_notes/interview/vue.html#mvvm">MVVM</a></li> <li><a href="/zys_notes/interview/vue.html#vue基本原理">Vue基本原理</a></li> <li><a href="/zys_notes/interview/vue.html#v-model-双向绑定的原理">双向绑定的原理</a></li> <li><a href="/zys_notes/interview/vue.html#vue的响应式原理">vue的响应式原理</a></li> <li><a href="/zys_notes/interview/vue.html#computed和watch的区别">computed和watch的区别</a></li> <li><a href="/zys_notes/interview/vue.html#slot插槽">slot插槽</a></li> <li><a href="/zys_notes/interview/vue.html#修饰符有哪些">修饰符有哪些</a></li> <li><a href="/zys_notes/interview/vue.html#v-if和v-show的区别">v-if和v-show的区别</a></li> <li><a href="/zys_notes/interview/vue.html#vue组件data必须为函数">vue组件data必须为函数</a></li> <li><a href="/zys_notes/interview/vue.html#vue的-nexttick">vue的$nextTick</a></li> <li><a href="/zys_notes/interview/vue.html#自定义指令directive">自定义指令directive</a></li> <li><a href="/zys_notes/interview/vue.html#vue模板编译">Vue模板编译</a></li> <li><a href="/zys_notes/interview/vue.html#v-for中key的作用">v-for中key的作用</a></li> <li><a href="/zys_notes/interview/vue.html#为什么v-if和v-for不建议一起用">为什么v-if和v-for不建议一起用</a></li> <li><a href="/zys_notes/interview/vue.html#混入mixin的理解">混入mixin的理解</a></li> <li><a href="/zys_notes/interview/vue.html#vue组件为什么只有一个根元素">vue组件为什么只有一个根元素</a></li> <li><a href="/zys_notes/interview/vue.html#组件和插件的区别">组件和插件的区别</a></li> <li><a href="/zys_notes/interview/vue.html#组件name的作用">组件name的作用</a></li></ul> <ul><li><a href="/zys_notes/interview/vue.html#父子组件生命周期执行顺序">父子组件生命周期执行顺序</a></li> <li><a href="/zys_notes/interview/vue.html#create和mounted中间间隔受哪些因素影响">create和mounted中间间隔受哪些因素影响</a></li> <li><a href="/zys_notes/interview/vue.html#一般在哪个生命周期请求异步数据">一般在哪个生命周期请求异步数据</a></li></ul> <ul><li><a href="/zys_notes/interview/vue.html#组件通信的方式有哪些">组件通信的方式有哪些</a></li> <li><a href="/zys_notes/vue/learn-vue2.html#父子组件双向绑定">父子组件双向绑定</a></li></ul> <ul><li><a href="/zys_notes/interview/vue.html#懒加载实现">懒加载实现</a></li> <li><a href="/zys_notes/interview/vue.html#vue-router路由模式">vue-router路由模式</a></li> <li><a href="/zys_notes/interview/vue.html#query和params的区别">query和params的区别</a></li> <li><a href="/zys_notes/interview/vue.html#$router和$route的区别">$router和$route的区别</a></li> <li><a href="/zys_notes/interview/vue.html#active-class">active-class</a></li> <li><a href="/zys_notes/interview/vue.html#路由守卫有哪些">路由守卫有哪些</a></li> <li><a href="/zys_notes/interview/vue.html#keep-alive的作用">keep-alive的作用</a></li></ul> <ul><li><a href="/zys_notes/interview/vue.html#vuex是什么">vuex是什么</a></li> <li><a href="/zys_notes/interview/vue.html#vuex中mutations和actions区别">vuex中mutations和actions区别</a></li> <li><a href="/zys_notes/interview/vue.html#如何保存页面状态">如何保存页面状态</a></li></ul> <ul><li><a href="/zys_notes/interview/vue.html#vue2与vue3的变化">vue2与vue3的变化</a></li> <li><a href="/zys_notes/interview/vue.html#项目中解决跨域">项目中解决跨域</a></li> <li><a href="/zys_notes/interview/vue.html#权限怎么做">权限怎么做</a></li> <li><a href="/zys_notes/interview/vue.html#搭建项目">搭建项目</a></li></ul> <h3 id="对vue看法"><a href="#对vue看法" class="header-anchor">#</a> 对Vue看法</h3> <p>是一个轻量型渐进式框架，可作为应用的一部分嵌入其中，容易迅速开发一些中小型项目</p> <h3 id="spa"><a href="#spa" class="header-anchor">#</a> SPA</h3> <p>单页面应用，应用加载好一个Web页面(html、js、css)后不会再随用户的操作重新加载或跳转，而是动态重写当前页面内容</p> <ul><li>优点：用户体验好、快，前后端分离开发</li> <li>缺点：初次加载耗时，SEO难度高</li></ul> <h3 id="mvvm"><a href="#mvvm" class="header-anchor">#</a> MVVM</h3> <ul><li>Model：数据层，数据业务逻辑处理和服务端交互。</li> <li>View：视图层，可以理解为展示给用户各种信息的DOM层。</li> <li>ViewModel：视图模型层，是View和Model之间的通信桥梁，一方面实现Data Banding另一方面实现了Dom Listener。</li></ul> <h3 id="vue基本原理"><a href="#vue基本原理" class="header-anchor">#</a> Vue基本原理</h3> <p>创建vue实例时，遍历data将属性转为get/set，在属性访问和修改时会通知变化<br>
然后每个组件都有相应的watcher，在渲染过程属性会记录为依赖，依赖项setter调用就会通知组件watcher重新计算更新</p> <h3 id="v-model-双向绑定的原理"><a href="#v-model-双向绑定的原理" class="header-anchor">#</a> v-model 双向绑定的原理</h3> <p>v-bind + v-on<br> <code>:value=&quot;abc&quot;</code> + <code>v-on:input=&quot;abc = $event.target.value&quot;</code></p> <p>数据劫持结合发布订阅<br>
初始化时监听器<code>Observer</code>对数据劫持监听<br> <code>Compile</code>解析模板指令，绑定更新函数，渲染和更新视图<br>
数据变化再由订阅者<code>Watcher</code>决定是否需要更新，是Observer、Compile通信桥梁<br>
交由订阅器<code>Dep</code>收集订阅者统一管理</p> <h3 id="vue的响应式原理"><a href="#vue的响应式原理" class="header-anchor">#</a> vue的响应式原理</h3> <ul><li>vue2的是通过 <code>Object.defineproperty</code> 数据劫持，初始化时对每个属性加上get/set（存在问题对象新增、删除属性界面不更新，得用$set（Vue内部通过重写函数）；通过下标改数组界面不更新</li> <li>vue3的是通过 <code>Proxy</code> 拦截对象中任意属性变化（优点不用监听每个属性），通过 <code>Reflect(反射)</code> 对源对象属性操作（优点，重复性操作属性时，Reflect它是有返回值的，Object会报错）</li></ul> <h3 id="computed和watch的区别"><a href="#computed和watch的区别" class="header-anchor">#</a> computed和watch的区别</h3> <ul><li>computed计算属性对数据进行一些转化后在显示，要依赖其他属性的，也就是依赖的属性值发生改变才会触发，并且它有缓存（多次调用只触发一次，和method方法的区别）</li> <li>watch监听器就是观察作用，监听数据变化是执行后续操作逻辑，无缓存</li></ul> <ul><li>Vue3中 <code>watch</code>和<code>watchEffect</code>区别<br>
watch既要指明监视的属性也要指明回调
而watchEffect不用指明监视的属性，回调中用到的数据有变化就会执行</li></ul> <h3 id="slot插槽"><a href="#slot插槽" class="header-anchor">#</a> slot插槽</h3> <p>是Vue的内容分发机制，其实就是让组件更有扩展性<br>
使用：子组件<code>slot</code>开启插槽，父组件使用子组件标签夹显示内容<br>
具名插槽(带有name去决定显示哪些不同内容)，作用域插槽（子组件提供数据，绑定在slot上）</p> <h3 id="filters过滤器"><a href="#filters过滤器" class="header-anchor">#</a> filters过滤器</h3> <p>用来改变数据的输出显示<br>
computed和method都是通过修改数据来触发控制输出显示的</p> <h3 id="修饰符有哪些"><a href="#修饰符有哪些" class="header-anchor">#</a> 修饰符有哪些</h3> <ul><li>表单修饰符v-model：<code>.trim</code> <code>.number</code> <code>.lazy</code></li> <li>事件修饰符：<code>.stop</code> <code>.prevent</code>等于<code>event.stopPropagation()</code> <code>.once</code> <code>.native</code></li> <li>鼠标：<code>.left</code> <code>.right</code> <code>.middle</code></li> <li>按键：<code>@keyup.enter</code></li> <li>v-bind修饰符：<code>:abc.sync</code></li></ul> <h3 id="v-if和v-show的区别"><a href="#v-if和v-show的区别" class="header-anchor">#</a> v-if和v-show的区别</h3> <p>都能控制元素的显隐<br>
v-show条件为false时，只是元素的display属性设置为none，节点还存在dom中<br>
v-if是直接添加与删除dom，开销大</p> <h3 id="vue组件data必须为函数"><a href="#vue组件data必须为函数" class="header-anchor">#</a> vue组件data必须为函数</h3> <p>函数return的都是新地址的data，这样多个组件之间数据不会相互影响，防止数据污染</p> <h3 id="vue的-nexttick"><a href="#vue的-nexttick" class="header-anchor">#</a> vue的$nextTick</h3> <p>vue更新dom是异步执行的，修改数据后视图不会立刻更新，在回调中拿到更新后的dom结构</p> <ul><li>数据变化后执行的dom操作</li> <li>如果在Vue生命周期create中操作dom<br>
$nextTick()返回一个promise对象</li></ul> <h3 id="自定义指令directive"><a href="#自定义指令directive" class="header-anchor">#</a> 自定义指令directive</h3> <p>使用场景：有些需要操作普通dom的情况（下拉菜单、图片懒加载、集成三方插件）</p> <h3 id="vue模板编译"><a href="#vue模板编译" class="header-anchor">#</a> Vue模板编译</h3> <p>模板template不是浏览器的标准无法解析渲染，所以需要一个模板编译转化的过程<br>
三个阶段：parse解析-&gt;转化抽象语法树AST，optimize优化，generate生成-&gt;转化为render函数</p> <h3 id="v-for中key的作用"><a href="#v-for中key的作用" class="header-anchor">#</a> v-for中key的作用</h3> <p>加key能更高效的更新虚拟dom，与dom的diff算法有关<br>
diff算法：diff算法在vue中主要是用于虚拟dom和渲染后的真实dom比较（同级比较，循环向中间比较）<br>
数据和key相同时dom不用更新<br>
数据发生改变，匹配元素顺序不会移动</p> <h3 id="为什么v-if和v-for不建议一起用"><a href="#为什么v-if和v-for不建议一起用" class="header-anchor">#</a> 为什么v-if和v-for不建议一起用</h3> <p>在同一元素上使用，v-for的优先级高，每次遍历后再判断影响性能<br>
解决：就是加template外层判断，不生成dom</p> <h3 id="混入mixin的理解"><a href="#混入mixin的理解" class="header-anchor">#</a> 混入mixin的理解</h3> <p>在需要相似度极高的组件时可以用到，让组件复用一些我们配置相同的生命周期或者方法</p> <h3 id="vue组件为什么只有一个根元素"><a href="#vue组件为什么只有一个根元素" class="header-anchor">#</a> vue组件为什么只有一个根元素</h3> <p>从三个方面来说<br>
Vue实例的根节点app入口不能有两个<br>
组件中template下的div也是实例的入口，其实就是树状结构的根处理为VDOM渲染成html<br>
树状结构是diff算法所要求的虚拟dom结构</p> <h3 id="组件和插件的区别"><a href="#组件和插件的区别" class="header-anchor">#</a> 组件和插件的区别</h3> <p>组件用来构成业务和界面模块，作用是App.vue<br>
插件通常用来给Vue添加全局功能，作用是Vue本身（全局属性、指令、混入）</p> <ul><li>编写和注册形式也不一样<br>
Vue.use(插件名)、Vue.component('组件名', {})</li></ul> <h3 id="组件name的作用"><a href="#组件name的作用" class="header-anchor">#</a> 组件name的作用</h3> <ul><li>配合<code>keep-alive</code>缓存组件状态</li> <li>组件递归操作，允许组件模板调自身</li> <li>vue调试工具vue-tools</li></ul> <hr> <h3 id="父子组件生命周期执行顺序"><a href="#父子组件生命周期执行顺序" class="header-anchor">#</a> 父子组件生命周期执行顺序</h3> <p>父beforeCreate -&gt; 父create -&gt; 父beforeMount -&gt; 子beforeCreate ... -&gt; 父mounted<br>
也就是父的<code>mounted</code>在子组件之后</p> <h3 id="create和mounted中间间隔受哪些因素影响"><a href="#create和mounted中间间隔受哪些因素影响" class="header-anchor">#</a> create和mounted中间间隔受哪些因素影响</h3> <p>mounted是在挂载完dom后调用的，比如页面复杂度，数据复杂度可能会影响dom的渲染</p> <h3 id="一般在哪个生命周期请求异步数据"><a href="#一般在哪个生命周期请求异步数据" class="header-anchor">#</a> 一般在哪个生命周期请求异步数据</h3> <p>created、beforeMount、mounted调用时data都已创建<br>
推荐在created中，更快获取到数据，减少页面加载时间</p> <hr> <h3 id="组件通信的方式有哪些"><a href="#组件通信的方式有哪些" class="header-anchor">#</a> 组件通信的方式有哪些</h3> <p><a href="https://blog.csdn.net/pdd11997110103/article/details/113563786" target="_blank" rel="noopener noreferrer">参考地址：https://blog.csdn.net/pdd11997110103/article/details/113563786<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></p> <ul><li>父传子用 <code>props</code>接收，子传父用<code>this.$emit('事件名', 参数)</code></li> <li>引用：父访问子 <code>this.$refs.aaa</code>、<code>this.$children</code>，子访问父 <code>this.$parent</code></li> <li>父和孙 <code>provide</code>/<code>Inject</code></li> <li>兄弟/跨级 <code>eventBus</code>，通过new Vue的bus对象--&gt;<code>bus.$emit</code>触发，<code>bus.$on</code>监听</li> <li><code>Vuex</code></li></ul> <h3 id="父子组件双向绑定"><a href="#父子组件双向绑定" class="header-anchor">#</a> 父子组件双向绑定</h3> <p>参考：
<a href="/zys_notes/vue/learn-vue2.html#父子组件双向绑定">vue -&gt; 组件化开发 -&gt; 父子组件双向绑定</a></p> <hr> <h3 id="懒加载实现"><a href="#懒加载实现" class="header-anchor">#</a> 懒加载实现</h3> <ul><li>箭头函数 + 动态引入import('')</li> <li>箭头函数 + require</li></ul> <h3 id="vue-router路由模式"><a href="#vue-router路由模式" class="header-anchor">#</a> vue-router路由模式</h3> <ul><li>hash<br>
地址栏上带有#的，也就是用来指示hash值的</li> <li>history<br>
对应的是HTML5History，<code>pushState()</code>和<code>replaceState()</code>
区别：history模式下，刷新就会向后端请求整个网址，前后端地址要完全一致，否则会404报错，处理就是前端加一个搭配404页面</li></ul> <h3 id="query和params的区别"><a href="#query和params的区别" class="header-anchor">#</a> query和params的区别</h3> <p>query方式可以使用name或path跳转，url上会显示参数<br>
params只能使用name方式跳转，路由不写参数url上会不显示，不在路由配参数刷新会丢参（存在sessionStorage）</p> <h3 id="router和-route的区别"><a href="#router和-route的区别" class="header-anchor">#</a> $router和$route的区别</h3> <p>$router是VueRouter实例，包含了所有路由以及路由的跳转方法<br>
$route是当前跳转的路由对象，里面含有一些路由信息（name、path、query、params等）</p> <h3 id="active-class"><a href="#active-class" class="header-anchor">#</a> active-class</h3> <p>router-link（渲染成a标签）路由匹配默认样式，修改在实例VueRouter处</p> <h3 id="路由守卫有哪些"><a href="#路由守卫有哪些" class="header-anchor">#</a> 路由守卫有哪些</h3> <p><code>router.beforeEach(to, from, next)</code>全局前置守卫，调用next()进入下一个页面<br> <code>router.afterEach(to, from, next)</code>后置守卫，不用主动调next()<br> <code>beforeEnter</code>路由独享守卫<br> <code>beforeRouteEnter</code>组件内守卫</p> <h3 id="keep-alive的作用"><a href="#keep-alive的作用" class="header-anchor">#</a> keep-alive的作用</h3> <ul><li>是Vue的一个内置组件，使被包含的组件保留状态，避免重新渲染（不走destoryed）</li> <li>两个属性
<ul><li><code>include</code>组件name匹配会被缓存</li> <li><code>exclude</code></li></ul></li> <li>只有使用keep-alive才生效的两个钩子函数
<ul><li>activated(){}</li> <li>deactivated (to, from, next){}</li></ul></li></ul> <hr> <h3 id="vuex是什么"><a href="#vuex是什么" class="header-anchor">#</a> vuex是什么</h3> <p>全局状态管理，可以将多个组件共享的数据存储在一个对象里</p> <h3 id="vuex中mutations和actions区别"><a href="#vuex中mutations和actions区别" class="header-anchor">#</a> vuex中mutations和actions区别</h3> <p>区别在于mutations中最好放同步方法，这样能跟踪到，对于异步操作放在actions中</p> <h3 id="如何保存页面状态"><a href="#如何保存页面状态" class="header-anchor">#</a> 如何保存页面状态</h3> <p>分两种情况</p> <ul><li>组件会被卸载
<ul><li><code>LocalStorage</code>/<code>SessionStorage</code></li> <li>路由传值</li></ul></li> <li>组件不会被卸载
父组件储存或<a href="/zys_notes/interview/vue.html#keep-alive的作用">keep-alive</a></li></ul> <hr> <h3 id="vue2与vue3的变化"><a href="#vue2与vue3的变化" class="header-anchor">#</a> vue2与vue3的变化</h3> <ul><li>Vue3最大化的兼容了Vue2（Vue3里可以写Vue2）</li> <li>源码升级，响应式原理的不同（Proxy），Diff算法的优化</li> <li>组件对象式声明方式，更好的支持TypeScript，Vue2需要用装饰器</li> <li>优化了tree shaking，提供了新的内置功能</li></ul> <hr> <h3 id="项目中解决跨域"><a href="#项目中解决跨域" class="header-anchor">#</a> 项目中解决跨域</h3> <p><a href="/zys_notes/ajax/#同源策略">参考：同源策略</a><br>
浏览器中不是同源就会拦截，所以一般利用构建工具/第三方库/自己搭一个开发服务器代理请求<br>
1、webpack--&gt;<code>vue.config.js</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">devServer</span><span class="token operator">:</span> <span class="token punctuation">{</span>
  <span class="token literal-property property">proxy</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token string-property property">'/zysDevApi'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
      <span class="token literal-property property">target</span><span class="token operator">:</span> <span class="token string">'http://localhost:3000'</span><span class="token punctuation">,</span>
      <span class="token literal-property property">changeOrigin</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
      <span class="token comment">// pathRewrite作用是把实际地址+给定值http://localhost:3000/abc</span>
      <span class="token comment">// 一般为空</span>
      <span class="token literal-property property">pathRewrite</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token string-property property">'^/zysDevApi'</span><span class="token operator">:</span> <span class="token string">''</span>
      <span class="token punctuation">}</span>
    <span class="token punctuation">}</span> 
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>2、vite--&gt;<code>vite.config.js</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token literal-property property">server</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">proxy</span><span class="token operator">:</span> <span class="token punctuation">{</span>
        <span class="token string-property property">'/zys_dev_api'</span><span class="token operator">:</span> <span class="token punctuation">{</span>
            <span class="token literal-property property">target</span><span class="token operator">:</span> <span class="token string">'http://localhost:4050'</span><span class="token punctuation">,</span>
            <span class="token literal-property property">changeOrigin</span><span class="token operator">:</span> <span class="token boolean">true</span><span class="token punctuation">,</span>
            <span class="token function-variable function">rewrite</span><span class="token operator">:</span> <span class="token punctuation">(</span><span class="token parameter">path</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> path<span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\/zys_dev_api</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token string">''</span><span class="token punctuation">)</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>3、通过<code>nginx</code>实现代理<br>
4、<code>CORS</code>服务端设置响应头<br>
5、<code>JSONP</code>借助有跨域能力的标签</p> <h3 id="权限怎么做"><a href="#权限怎么做" class="header-anchor">#</a> 权限怎么做</h3> <ul><li>路由权限
<ul><li>动态生成路由（数据前后端都可以，后端的话映射），<code>router.addRoutes()</code>添加，再通过new实例<code>.matcher</code>实现第二次清空</li> <li>也可通过<code>meta</code>设定权限标识，在<code>beforeEach((to, from, next) =&gt; {}))</code>去判断进行跳转</li></ul></li> <li>按钮权限：通过<code>自定义权限指令</code>控制</li></ul> <h3 id="搭建项目"><a href="#搭建项目" class="header-anchor">#</a> 搭建项目</h3> <ul><li>根据项目需求采用合适的技术栈，构建方式：脚手架/模板 <code>vue + ts + vite</code><br>
第三方依赖：</li> <li>UI组件库<code>npm i element-ui</code></li> <li>安装路由<code>npm i vue-router</code></li> <li>全局状态管理<code>npm i vuex</code></li> <li>安装http工具axios，封装请求工具</li> <li>css预编译器，全局样式和主题色的修改<br>
然后其它的：</li> <li>git hooks钩子</li> <li>代码规范和代码美化工具</li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">2024年12月28日星期六早上8点26分</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/zys_notes/interview/encapsulation.html" class="prev">
        实现总结
      </a></span> <span class="next"><a href="/zys_notes/interview/js.html">
        JS系列
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/zys_notes/assets/js/app.27d2a2d1.js" defer></script><script src="/zys_notes/assets/js/2.dfcfa016.js" defer></script><script src="/zys_notes/assets/js/24.9b45613e.js" defer></script>
  </body>
</html>
