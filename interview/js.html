<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>JS系列 | zys-conclusion</title>
    <meta name="generator" content="VuePress 1.9.7">
    <link rel="icon" href="/zys_notes/assets/imgs/favicon.ico">
    <meta name="description" content="Welcome to zys_notes">
    <meta name="author" content="zys">
    <meta name="keywords" content="使用vuepress">
    
    <link rel="preload" href="/zys_notes/assets/css/0.styles.a1da0401.css" as="style"><link rel="preload" href="/zys_notes/assets/js/app.27d2a2d1.js" as="script"><link rel="preload" href="/zys_notes/assets/js/2.dfcfa016.js" as="script"><link rel="preload" href="/zys_notes/assets/js/23.55ad0ebc.js" as="script"><link rel="prefetch" href="/zys_notes/assets/js/10.cfacbde0.js"><link rel="prefetch" href="/zys_notes/assets/js/11.7152949e.js"><link rel="prefetch" href="/zys_notes/assets/js/12.89311dc4.js"><link rel="prefetch" href="/zys_notes/assets/js/13.f00188eb.js"><link rel="prefetch" href="/zys_notes/assets/js/14.703aa30f.js"><link rel="prefetch" href="/zys_notes/assets/js/15.c9296715.js"><link rel="prefetch" href="/zys_notes/assets/js/16.7537c97d.js"><link rel="prefetch" href="/zys_notes/assets/js/17.beaa65a7.js"><link rel="prefetch" href="/zys_notes/assets/js/18.53136da5.js"><link rel="prefetch" href="/zys_notes/assets/js/19.35e09296.js"><link rel="prefetch" href="/zys_notes/assets/js/20.b72ad227.js"><link rel="prefetch" href="/zys_notes/assets/js/21.d60756f5.js"><link rel="prefetch" href="/zys_notes/assets/js/22.c3b19fb6.js"><link rel="prefetch" href="/zys_notes/assets/js/24.9b45613e.js"><link rel="prefetch" href="/zys_notes/assets/js/25.42cf1f68.js"><link rel="prefetch" href="/zys_notes/assets/js/26.3af6579d.js"><link rel="prefetch" href="/zys_notes/assets/js/27.a765196c.js"><link rel="prefetch" href="/zys_notes/assets/js/28.9641a23b.js"><link rel="prefetch" href="/zys_notes/assets/js/29.58de9ec5.js"><link rel="prefetch" href="/zys_notes/assets/js/3.48a24a76.js"><link rel="prefetch" href="/zys_notes/assets/js/30.042fd9db.js"><link rel="prefetch" href="/zys_notes/assets/js/31.09968ecf.js"><link rel="prefetch" href="/zys_notes/assets/js/32.de245d2f.js"><link rel="prefetch" href="/zys_notes/assets/js/33.a4ef8d72.js"><link rel="prefetch" href="/zys_notes/assets/js/4.0e8dcff8.js"><link rel="prefetch" href="/zys_notes/assets/js/5.aa9851b9.js"><link rel="prefetch" href="/zys_notes/assets/js/6.99ad772a.js"><link rel="prefetch" href="/zys_notes/assets/js/7.0adce77b.js"><link rel="prefetch" href="/zys_notes/assets/js/8.e3455c10.js"><link rel="prefetch" href="/zys_notes/assets/js/9.6f3c5772.js">
    <link rel="stylesheet" href="/zys_notes/assets/css/0.styles.a1da0401.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/zys_notes/" class="home-link router-link-active"><img src="/zys_notes/assets/imgs/header.png" alt="zys-conclusion" class="logo"> <span class="site-name can-hide">zys-conclusion</span></a> <div class="links"><div class="search-box"><input aria-label="Search" autocomplete="off" spellcheck="false" value=""> <!----></div> <nav class="nav-links can-hide"><div class="nav-item"><a href="/zys_notes/vp-notes/" class="nav-link">
  Vuepress
</a></div><div class="nav-item"><a href="/zys_notes/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/zys_notes/interview/vue.html" class="nav-link">
  面试问题
</a></div><div class="nav-item"><a href="/zys_notes/timeline/" class="nav-link">
  时间线
</a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/zys_notes/vp-notes/" class="nav-link">
  Vuepress
</a></div><div class="nav-item"><a href="/zys_notes/vue/" class="nav-link">
  Vue
</a></div><div class="nav-item"><a href="/zys_notes/interview/vue.html" class="nav-link">
  面试问题
</a></div><div class="nav-item"><a href="/zys_notes/timeline/" class="nav-link">
  时间线
</a></div> <!----></nav>  <ul class="sidebar-links"><li><a href="/zys_notes/" aria-current="page" class="sidebar-link">首页</a></li><li><section class="sidebar-group collapsable depth-0"><a href="/zys_notes/vue/start" class="sidebar-heading clickable"><span>vue学习</span> <span class="arrow right"></span></a> <!----></section></li><li><a href="/zys_notes/vite/vite.html" class="sidebar-link">vite学习</a></li><li><a href="/zys_notes/uniapp/uniapp.html" class="sidebar-link">uniapp学习</a></li><li><a href="/zys_notes/angular/angular.html" class="sidebar-link">Angular</a></li><li><a href="/zys_notes/websocket/websocket.html" class="sidebar-link">Websocket</a></li><li><section class="sidebar-group depth-0"><a href="/zys_notes/basis/" class="sidebar-heading clickable"><span>前端基础</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/zys_notes/basis/learn-html.html" class="sidebar-link">html部分</a></li><li><a href="/zys_notes/basis/learn-css.html" class="sidebar-link">css部分</a></li></ul></section></li><li><a href="/zys_notes/ajax/" class="sidebar-link">ajax</a></li><li><a href="/zys_notes/promise/" class="sidebar-link">Promise</a></li><li><a href="/zys_notes/axios/" class="sidebar-link">axios</a></li><li><a href="/zys_notes/iframe/" class="sidebar-link">iframe通信</a></li><li><section class="sidebar-group depth-0"><a href="/zys_notes/interview/" class="sidebar-heading clickable router-link-active open"><span>准备</span> <!----></a> <ul class="sidebar-links sidebar-group-items"><li><a href="/zys_notes/interview/encapsulation.html" class="sidebar-link">实现总结</a></li><li><a href="/zys_notes/interview/vue.html" class="sidebar-link">Vue系列</a></li><li><a href="/zys_notes/interview/js.html" aria-current="page" class="active sidebar-link">JS系列</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#基础" class="sidebar-link">基础</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#数据类型" class="sidebar-link">数据类型</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#typeof和instanceof" class="sidebar-link">typeof和instanceof</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#null和undefined区别" class="sidebar-link">null和undefined区别</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#判断对象是空对象的方法" class="sidebar-link">判断对象是空对象的方法</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#和-区别" class="sidebar-link">==和===区别</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#字符串常见方法" class="sidebar-link">字符串常见方法</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#数组常见方法" class="sidebar-link">数组常见方法</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#数组去重方法" class="sidebar-link">数组去重方法</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#闭包" class="sidebar-link">闭包</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#防抖节流" class="sidebar-link">防抖节流</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#浅拷贝深拷贝" class="sidebar-link">浅拷贝深拷贝</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#for-in和for-of区别" class="sidebar-link">for...in和for...of区别</a></li></ul></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#es6篇" class="sidebar-link">ES6篇</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#var、let、const" class="sidebar-link">var、let、const</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#箭头函数和普通函数的区别" class="sidebar-link">箭头函数和普通函数的区别</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#promise" class="sidebar-link">Promise</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#async-await" class="sidebar-link">async/await</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#proxy" class="sidebar-link">Proxy</a></li></ul></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#其它" class="sidebar-link">其它</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#内存泄露" class="sidebar-link">内存泄露</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#dom和bom" class="sidebar-link">DOM和BOM</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#作用域和作用域链" class="sidebar-link">作用域和作用域链</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#原型和原型链" class="sidebar-link">原型和原型链</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#事件代理" class="sidebar-link">事件代理</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#事件循环机制-event-loop" class="sidebar-link">事件循环机制 Event Loop</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#ajax" class="sidebar-link">AJAX</a></li><li class="sidebar-sub-header"><a href="/zys_notes/interview/js.html#axios" class="sidebar-link">Axios</a></li></ul></li></ul></li><li><a href="/zys_notes/interview/css.html" class="sidebar-link">CSS系列</a></li><li><a href="/zys_notes/interview/webpack.html" class="sidebar-link">Webpack</a></li><li><a href="/zys_notes/interview/http.html" class="sidebar-link">http系列</a></li><li><a href="/zys_notes/interview/webgis.html" class="sidebar-link">WebGis系列</a></li><li><a href="/zys_notes/interview/vueDiff.html" class="sidebar-link">Vue虚拟Dom与Diff算法</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h2 id="基础"><a href="#基础" class="header-anchor">#</a> 基础</h2> <h3 id="数据类型"><a href="#数据类型" class="header-anchor">#</a> 数据类型</h3> <p>String、Number、Boolean、null、undefined、Object、Symbol、BigInt<br>
引用：对象、数组、函数<br>
ES6：<br>
Symbol：创建后独一无二且不可变的数据类型，解决变量冲突<br>
BigInt：可以安全存储和操作大整数</p> <h3 id="typeof和instanceof"><a href="#typeof和instanceof" class="header-anchor">#</a> typeof和instanceof</h3> <p>typeof：返回类型字符串，（null、对象和数组判断为object类型）<br>
instanceof：返回布尔值，只能判断引用数据类型（内部运行机制是判断在原型链中能否找到该类型的原型）<br> <code>Object.prototype.toString.call()</code>使用Object对象的原型方法toString，通用<code>[Object 类型]</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">getType</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">return</span> <span class="token class-name">Object</span><span class="token punctuation">.</span>prototype<span class="token punctuation">.</span><span class="token function">toString</span><span class="token punctuation">.</span><span class="token function">call</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">.</span><span class="token function">replace</span><span class="token punctuation">(</span><span class="token regex"><span class="token regex-delimiter">/</span><span class="token regex-source language-regex">^\[object (\S+)\]$</span><span class="token regex-delimiter">/</span></span><span class="token punctuation">,</span> <span class="token string">'$1'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="null和undefined区别"><a href="#null和undefined区别" class="header-anchor">#</a> null和undefined区别</h3> <p>初始化空对象，未定义<br>
null用type of判断时会返回object<br>
相等返回true，全等返回false</p> <h3 id="判断对象是空对象的方法"><a href="#判断对象是空对象的方法" class="header-anchor">#</a> 判断对象是空对象的方法</h3> <p><code>Object.keys(obj).length == 0</code>、<code>JSON.stringify(obj) == '{}'</code></p> <h3 id="和-区别"><a href="#和-区别" class="header-anchor">#</a> ==和===区别</h3> <p>相等会做类型转换，再进行值比较（true==1）
全等要类型相同，值也要相同</p> <h3 id="字符串常见方法"><a href="#字符串常见方法" class="header-anchor">#</a> 字符串常见方法</h3> <ul><li>增：<code>+</code>拼接，<code>concat()</code>拼接新的字符串</li> <li>删/截取：<code>slice()</code>，<code>substring()</code>，<code>substr()</code>接收一个或两个参数(顾头不顾尾)</li> <li>查：<code>indexOf()</code>返回下标，<code>includes()</code>返回布尔</li> <li>大小写转化：<code>toUpperCase()</code>、 <code>toLowerCase()</code></li></ul> <h3 id="数组常见方法"><a href="#数组常见方法" class="header-anchor">#</a> 数组常见方法</h3> <p>数组操作基本是改变元数据</p> <ul><li>增：<code>.push()</code>，<code>.unshift()</code>开头添加，<code>新数组=a.concat(...)</code>不改变原数据，返回合并后新数组</li> <li>删：<code>.pop()</code>末尾删除，<code>shift()</code>删第一项<br> <code>新数组=a.slice(begin, end)</code><br>
不改变原数据，一个或两个参数<br>
一个参数，删除之前元素<br>
两个参数，截取，end位置元素不包括</li> <li>查： <code>indexOf()</code>返回下标，<code>includes()</code>返回布尔</li> <li><code>.splice(开始位置, 删除数量, 插入的元素)</code><br>
改变原数据，返回删除元素数组<br>
一个参数，删除之后元素<br>
两个参数<br>
三个参数</li> <li>迭代方法（不改变原数据）：<code>.find(() =&gt; )</code>返回匹配项，<code>.some(() =&gt; )</code>有一个满足返回true，<code>.every(() =&gt; )</code>所有满足返回true，<code>b=a.filter(() =&gt; )</code>返回满足数组，<code>.map()</code></li> <li><code>reverse()</code>反转，<code>sort(a,b=&gt;)</code>排序(a-b小到大)</li> <li>es6：<code>Array.from()</code>、<code>Array.of()</code>、<code>find</code>、<code>includes()</code>、<code>flatMap()</code></li></ul> <h3 id="数组去重方法"><a href="#数组去重方法" class="header-anchor">#</a> 数组去重方法</h3> <ul><li>循环利用<code>indexOf()</code>方法往新数组push去重，<code>.indexOf(arr[i]) === -1</code></li> <li>利用es6的<code>Set</code>去重，<code>Array.from(new Set())</code></li> <li>利用<code>filter</code>去重，<code>arr.filter((val, index) =&gt; arr.indexOf(val) === index)</code></li> <li>利用Map数据结构去重，<code>arr.filter(val =&gt; !map.has(val) &amp;&amp; map.set(val, 1))</code></li></ul> <h3 id="闭包"><a href="#闭包" class="header-anchor">#</a> 闭包</h3> <p>函数套函数，内层函数中访问到其外层函数的作用域</p> <ul><li>两个优点：保存和保护
<ul><li>保护内部变量不受外界干扰，适合模块化开发，在ES6 module和CommonJs都能看到</li> <li>保存就是形成一个不销毁的作用域，一直存在内存中，容易造成内存泄露</li> <li>主要应用<a href="/zys_notes/interview/encapsulation.html#防抖节流">防抖节流</a></li></ul></li></ul> <h3 id="防抖节流"><a href="#防抖节流" class="header-anchor">#</a> 防抖节流</h3> <p>都是防止一段时间重复性操作<br> <code>防抖</code>：n秒后执行操作，若n秒内重复触发，重新计时（输入框发送请求的防抖）<br> <code>节流</code>：n秒内只执行一次（提交按钮）<br> <a href="/zys_notes/interview/encapsulation.html#防抖节流">防抖节流实现</a></p> <h3 id="浅拷贝深拷贝"><a href="#浅拷贝深拷贝" class="header-anchor">#</a> 浅拷贝深拷贝</h3> <p>针对于Object和Array引用数据类型</p> <ul><li>浅拷贝：属性是基本类型，拷贝的是基本类型的值，属性是引用类型，拷贝的就是内存地址（指向同一块内存）<br>
赋值和浅拷贝的区别在于第一层的基本数据类型，赋值后改值源对象会改变<br> <code>手写代码</code>，<code>Object.assign</code>，<code>拓展运算符...</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">shallowClone</span><span class="token punctuation">(</span><span class="token parameter">obj</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">const</span> newObj <span class="token operator">=</span> <span class="token punctuation">{</span><span class="token punctuation">}</span><span class="token punctuation">;</span>
        <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> obj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
            <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
                newObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">;</span>
            <span class="token punctuation">}</span>
        <span class="token punctuation">}</span>
        <span class="token keyword">return</span> newObj<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
</code></pre></div><ul><li>深拷贝：将一个对象从内存中完整的拷贝一份出来（不共享同一块内存），修改新对象不会影响原对象
<code>手写代码递归</code>，<code>lodash.cloneDeep</code>，<code>JSON.string（会忽略undefined，symbol，函数）</code></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> hash <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">WeakMap</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token operator">==</span> <span class="token keyword">null</span><span class="token punctuation">)</span> <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">Date</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">Date</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>obj <span class="token keyword">instanceof</span> <span class="token class-name">RegExp</span><span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token function">RegExp</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token keyword">typeof</span> obj <span class="token operator">!==</span> <span class="token string">'object'</span><span class="token punctuation">)</span> <span class="token keyword">return</span> obj<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>hash<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token keyword">return</span> hash<span class="token punctuation">.</span><span class="token function">get</span><span class="token punctuation">(</span>obj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">let</span> cloneObj <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">obj<span class="token punctuation">.</span>constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    hash<span class="token punctuation">.</span><span class="token function">set</span><span class="token punctuation">(</span>obj<span class="token punctuation">,</span> cloneObj<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> key <span class="token keyword">in</span> cloneObj<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        <span class="token keyword">if</span> <span class="token punctuation">(</span>obj<span class="token punctuation">.</span><span class="token function">hasOwnProperty</span><span class="token punctuation">(</span>key<span class="token punctuation">)</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
            cloneObj<span class="token punctuation">[</span>key<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token function">deepClone</span><span class="token punctuation">(</span>obj<span class="token punctuation">[</span>key<span class="token punctuation">]</span><span class="token punctuation">,</span> hash<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token punctuation">}</span>
    <span class="token punctuation">}</span>
    <span class="token keyword">return</span> cloneObj<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="for-in和for-of区别"><a href="#for-in和for-of区别" class="header-anchor">#</a> for...in和for...of区别</h3> <p>for in：遍历对象（拿key），遍历数组（拿索引）<br>
for of：遍历数组（拿每项item）</p> <h2 id="es6篇"><a href="#es6篇" class="header-anchor">#</a> ES6篇</h2> <h3 id="var、let、const"><a href="#var、let、const" class="header-anchor">#</a> var、let、const</h3> <p>变量提升、作用域、声明和修改</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">4</span><span class="token punctuation">;</span>
<span class="token keyword">function</span> <span class="token function">fn</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>a<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">5</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">fn</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token comment">// undefined</span>

<span class="token keyword">function</span> <span class="token function">a</span> <span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">var</span> a<span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span> <span class="token comment">// function</span>
<span class="token keyword">var</span> a <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">typeof</span> a<span class="token punctuation">)</span> <span class="token comment">// number</span>
<span class="token comment">// 函数提升优先级高于变量提升，不会被变量声明覆盖，但是会被同名变量赋值后覆盖</span>
</code></pre></div><h3 id="箭头函数和普通函数的区别"><a href="#箭头函数和普通函数的区别" class="header-anchor">#</a> 箭头函数和普通函数的区别</h3> <ul><li>写法简洁</li> <li>没有自己的this，继承上一层的this而且指向不会改变</li> <li>没有prototype，不能new一个箭头函数</li></ul> <h3 id="promise"><a href="#promise" class="header-anchor">#</a> Promise</h3> <p>是异步编程新的一种解决方案，支持链式调用解决回调地狱的问题</p> <h3 id="async-await"><a href="#async-await" class="header-anchor">#</a> async/await</h3> <p>基于Promise实现的，好处就是让异步的代码看起来和同步代码一样，代码容易阅读和维护</p> <ul><li>async声明一个异步的function，返回值为Promise对象</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// 函数里return结果，相当于Promise.resolve()</span>
<span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">abc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
<span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token function">abc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>result<span class="token punctuation">,</span> <span class="token number">1122</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// Promise对象</span>
</code></pre></div><ul><li>await等待一个异步方法执行完成，一般右侧为Promise对象</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">abc</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">resolve</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 123</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token keyword">await</span> <span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>  <span class="token comment">// 123</span>
  <span class="token keyword">try</span> <span class="token punctuation">{</span>  <span class="token comment">// 失败要try...catch捕获</span>
    <span class="token keyword">const</span> result3 <span class="token operator">=</span> <span class="token keyword">await</span> Promise<span class="token punctuation">.</span><span class="token function">reject</span><span class="token punctuation">(</span><span class="token string">'error'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">catch</span> <span class="token punctuation">(</span>e<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>e<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
<span class="token function">abc</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
</code></pre></div><ul><li>优势：如果是链式调用，Promise得用then去执行，async/await写法几乎和同步代码一样</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">async</span> <span class="token keyword">function</span> <span class="token function">getResult</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> result1 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">异步方法1</span><span class="token punctuation">(</span><span class="token number">123</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> result2 <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">异步方法2</span><span class="token punctuation">(</span>result1<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> result <span class="token operator">=</span> <span class="token keyword">await</span> <span class="token function">异步方法3</span><span class="token punctuation">(</span>result2<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="proxy"><a href="#proxy" class="header-anchor">#</a> Proxy</h3> <p>用于创建一个对象代理，实现对对象的拦截和自定义<br>
vue3的响应式就是通过<code>proxy</code>实现</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token comment">// target目标对象，handler拦截属性（set，get等）</span>
<span class="token keyword">var</span> proxy <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Proxy</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
<span class="token comment">// 取消代理</span>
proxy<span class="token punctuation">.</span><span class="token function">revocable</span><span class="token punctuation">(</span>target<span class="token punctuation">,</span> handler<span class="token punctuation">)</span>
</code></pre></div><h2 id="其它"><a href="#其它" class="header-anchor">#</a> 其它</h2> <h3 id="内存泄露"><a href="#内存泄露" class="header-anchor">#</a> 内存泄露</h3> <p>说白了就是内存使用了之后没有被浏览器回收<br>
闭包一定会造成内存泄漏吗？看它有没有被外界接收了<br>
垃圾回收方式：<code>标记清除</code>，<code>引用计数</code></p> <ul><li>使用未声明的变量，意外创建了一个全局变量</li> <li>未清理定时器<code>setInterval()</code>，<code>clearInterval()</code></li> <li>闭包，函数内部的局部变量，没有释放</li> <li>删除dom元素，没有清理dom的引用</li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">var</span> a <span class="token operator">=</span> document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn'</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
document<span class="token punctuation">.</span>body<span class="token punctuation">.</span><span class="token function">removeChild</span><span class="token punctuation">(</span>document<span class="token punctuation">.</span><span class="token function">getElementById</span><span class="token punctuation">(</span><span class="token string">'btn'</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 解决手动删除 a = null;</span>
</code></pre></div><h3 id="dom和bom"><a href="#dom和bom" class="header-anchor">#</a> DOM和BOM</h3> <p>DOM：文档对象模型，是W3C标准规范，主要学习操作页面元素<br>
BOM：浏览器对象模型<br>
常见的BOM对象：window(核心对象)包含--&gt;location、navigator、screen、history</p> <h3 id="作用域和作用域链"><a href="#作用域和作用域链" class="header-anchor">#</a> 作用域和作用域链</h3> <ul><li>作用域
<ul><li>全局作用域：不在函数和大括号中声明的变量</li> <li>函数作用域</li> <li>块级作用域</li></ul></li> <li>作用域链：js中使用变量，会在当前作用域开始，层层向上寻找</li></ul> <h3 id="原型和原型链"><a href="#原型和原型链" class="header-anchor">#</a> 原型和原型链</h3> <p>原型：js中是使用函数创建对象的，都有一个prototype属性，也就是原型对象，用来存放属性和方法<br>
原型链：我理解得本质就是个列表，当返回函数实例时，会有__proto__属性指向函数的原型，当访问对象属性时会搜索该对象的原型，层层向上找<br> <code>p.__proto__===Person.prototype</code><br> <code>Object.prototypep.__proto__===null</code></p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span><span class="token punctuation">}</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span><span class="token class-name">Person</span><span class="token punctuation">.</span>prototype<span class="token punctuation">)</span><span class="token punctuation">;</span>

<span class="token comment">// 输出</span>
<span class="token punctuation">{</span>
  <span class="token literal-property property">constructor</span><span class="token operator">:</span> ƒ <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token literal-property property">__proto__</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">constructor</span><span class="token operator">:</span> ƒ <span class="token function">Object</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token literal-property property">hasOwnProperty</span><span class="token operator">:</span> ƒ <span class="token function">hasOwnProperty</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token literal-property property">isPrototypeOf</span><span class="token operator">:</span> ƒ <span class="token function">isPrototypeOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token literal-property property">propertyIsEnumerable</span><span class="token operator">:</span> ƒ <span class="token function">propertyIsEnumerable</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token literal-property property">toLocaleString</span><span class="token operator">:</span> ƒ <span class="token function">toLocaleString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token literal-property property">toString</span><span class="token operator">:</span> ƒ <span class="token function">toString</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token literal-property property">valueOf</span><span class="token operator">:</span> ƒ <span class="token function">valueOf</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>

<span class="token keyword">const</span> p <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>p<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token comment">// 输出</span>
<span class="token punctuation">{</span>
  <span class="token literal-property property">__proto__</span><span class="token operator">:</span> <span class="token punctuation">{</span>
    <span class="token literal-property property">constructor</span><span class="token operator">:</span> ƒ <span class="token function">Person</span><span class="token punctuation">(</span><span class="token punctuation">)</span>
    <span class="token literal-property property">__proto__</span><span class="token operator">:</span> Object
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="事件代理"><a href="#事件代理" class="header-anchor">#</a> 事件代理</h3> <p>事件流经过三个阶段：捕获--&gt;目标--&gt;冒泡<br>
事件代理就是基于事件冒泡机制<br>
就是把一组元素的事件委托到父级或更外层元素上，绑定事件是外层元素<br>
优点：动态绑定减少重复工作，减少内存使用</p> <h3 id="事件循环机制-event-loop"><a href="#事件循环机制-event-loop" class="header-anchor">#</a> 事件循环机制 Event Loop</h3> <p>JS执行代码是单线程的，每次只能做一件事，遇到异步任务不会一直等待返回结果，会将对应的任务放在事件队列中（微任务、宏任务）<br>
事件循环可理解为一个桥梁<br>
首先执行同步代码这属于宏任务，执行中遇到微任务加入到微任务队列（宏任务也一样），执行完当前宏任务后，有微任务就执行微任务<br>
然后浏览器会执行渲染，接着JS线程执行下一个宏任务</p> <ul><li>宏任务：宿主环境提供，script代码、setTimeout、setInterval、ajax、UI交互</li> <li>微任务：语言本身提供，Promise、mutationObserver</li></ul> <h3 id="ajax"><a href="#ajax" class="header-anchor">#</a> AJAX</h3> <p>异步更新网页（更新网页对应部分，不需要刷新整个网页）</p> <ul><li>过程
<ul><li>创建XMLHttpRequest实例对象（new XMLHttpRequest()）</li> <li>与服务器建立连接.open</li> <li>发送给服务端.send</li></ul></li></ul> <h3 id="axios"><a href="#axios" class="header-anchor">#</a> Axios</h3> <p>支持promise、浏览器端发送AJAX请求、node端发http请求</p></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">2024年9月18日星期三下午5点34分</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/zys_notes/interview/vue.html" class="prev">
        Vue系列
      </a></span> <span class="next"><a href="/zys_notes/interview/css.html">
        CSS系列
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"><!----></div></div>
    <script src="/zys_notes/assets/js/app.27d2a2d1.js" defer></script><script src="/zys_notes/assets/js/2.dfcfa016.js" defer></script><script src="/zys_notes/assets/js/23.55ad0ebc.js" defer></script>
  </body>
</html>
